/****************************************************************************************************
 *File		:	CMControl.c
 *Author	:  @YangTianhao ,490999282@qq.com，@TangJiaxin ,tjx1024@126.com
 *Version	: V1.0
 *Update	: 2017.12.11
 *Description: 	Control Chassis Motors.
								CMControlLoop() shows the way to control the motion of chassis in different states.
                Use PID to optimize Chassis motor control.
 *****************************************************************************************************/

#include "main.h"

int16_t CMFollowVal=0; 			    //底盘跟随值
int16_t speedA_final,speedB_final,speedC_final,speedD_final;
//PID_Struct CMPid,CMFollowPid,CMFollowPid_speed;                 //底盘运动pid、跟随pid
float step=100,keymove_x=0,keymove_y=0,m=0,n=0,q=0;           //step-速度变化率  x-x轴方向变化值 y-y速度变化值;




u8 quick_spin_flag=0;
int16_t CMFollowVal_QUICK=0;


PID_Type SPFOLLOW,SPCHIASSISA,SPCHIASSISB,SPCHIASSISC,SPCHIASSISD,SPFOLLOW_SPEED;


float max_output_speed=600;

float singl_max=4000;
float speed_step=500;
float output_current_sum=0;

float spin_y=0;
float spin_x=0;

u8 climb_mode_flag=0;


float cm_normal_p=2.0;
float cm_normal_i=0.8;
float cm_normal_d=0.2;

float cm_climb_p=8.5;
float cm_climb_i=20;
float cm_climb_d=0.0;

float rotate_speed=250;
int rotate_speed_dir=1;
float rotate_change_para=1;
int rotate_counter=0;
int rotate_counter_100ms=0;

/*************balance chiassis********/

/* parameters for PID controller */
float pp=180.0;
float pi=10.0;
float pd=5.0;
float sp=50;
float si=1.0;
float sd=3.0;


/* physical parameters of the balancing robot */
float M_bottom = 4;       // mass of the lower part of the chassis (kg)
float m_top = 2;          // mass of the upper part of the chassis (kg)
float b = 0.1;            // estimate of viscous friction coefficient (N-m-s)
float h = 0.25;           // length from top of the robot to line passing through the two wheels (m)
float I = 0.125;				  // moment of inertia of the pendulum (kg*m^2), estimated with I=(1/3)*(M+m)*h^2 or I=(1/3)*M*h^2
float g = 9.82;           // acceleration due to gravity (m/s^2)
float l = 0.20;           // length between the pendulum center of mass and the line passing through the two wheels (m)
float r = 0.075;          // wheel radius (m)
float k_T_F = 26.667;     // coefficient that, given a torque T, computes the linear force to the wheels F = k_T_F*T = (2/r)*T 


/* entries of the dynamics matrix (A) */
//contiguous time 2x2
//float A33 = 0;
//float A34 = 1;
//float A43 = 0;
//float A44 = 36.9312;
//contiguous time 3x3
//float A22 = -0.0279;
//float A23 = 1.1210;
//float A24 = 0;
//float A32 = 0;
//float A33 = 0;
//float A34 = 1;
//float A42 = -0.0457;
//float A43 = 17.9361;
//float A44 = 0;
//discrete time 2x2
//float A33 = 1.0018;
//float A34 = 0.01;
//float A43 = 0.3695;
//float A44 = 1.0018;
//discrete time 3x3
//float A22 = 1;
//float A23 = 0.0011;
//float A24 = 0;
//float A32 = 0;
//float A33 = 1;
//float A34 = 0.0010;
//float A42 = 0;	//before was -0.0457, but it was probably an error
//float A43 = 0.0179;
//float A44 = 0;
//discrete time 4x4 (linearization of nonlinear model)
float A11 = 1;
float A12 = 0.0010;
float A13 = 0;
float A14 = 0;
float A21 = 0;
float A22 = 1;
float A23 = 0.0015;
float A24 = 0;
float A31 = 0;
float A32 = 0;
float A33 = 1;
float A34 = 0.0010;
float A41 = 0;
float A42 = 0;
float A43 = 0.0220;
float A44 = 1;

/* entries of the inputs matrix (B) */
//contiguous time 2x1
//float B3 = 0;
//float B4 = 0.9402;
//contiguous time 3x1
//float B2 = 7.9583;
//float B3 = 0;
//float B4 = 13.0463;
//discrete time 2x1
//float B3 = 0;
//float B4 = 0.0094;
//discrete time 3x1
//float B2 = 0.0080;
//float B3 = 0;
//float B4 = 0.0130;
//discrete time 4x1 (linearization of nonlinear model)
float B1 = 0;
float B2 = 0.0249;
float B3 = 0;
float B4 = 0.0100;

/* entries of the outputs matrix (C) */
//Pitch and Pitch_gyro are measured from the sensors
//float C22 = 0;
//float C23 = 0;
//float C24 = 0;
//float C32 = 0;
//float C33 = 1;
//float C34 = 0;
//float C42 = 0;
//float C43 = 0;
//float C44 = 1;
//Pos and Pitch are measured from the sensors
float C11 = 1;
float C12 = 0;
float C13 = 0;
float C14 = 0;
float C31 = 0;
float C32 = 0;
float C33 = 1;
float C34 = 0;

/* initial entries of the Kalman filter matrix (Kf) */
//Pitch and Pitch_gyro are measured from the sensors, and Pos_dot is estimated
//float Kf23;
//float Kf24;
//float Kf33;
//float Kf34;
//float Kf43;
//float Kf44;
//Pos and Pitch are measured from the sensors, and Pos_dot and Pitch_gyro are estimated
float Kf11;
float Kf13;
float Kf21;
float Kf23;
float Kf31;
float Kf33;
float Kf41;
float Kf43;

/* initial entries of the error covariance matrix of 'x - x_estim' (P) */
//Pos_dot, Pitch and Pitch_gyro
//float P22 = 1;
//float P23 = 0;
//float P24 = 0;
//float P32 = 0;
//float P33 = 1;
//float P34 = 0;
//float P42 = 0;
//float P43 = 0;
//float P44 = 1;
//Pos, Pos_dot, Pitch and Pitch_gyro
float P11 = 1;
float P12 = 0;
float P13 = 0;
float P14 = 0;
float P21 = 0;
float P22 = 1;
float P23 = 0;
float P24 = 0;
float P31 = 0;
float P32 = 0;
float P33 = 1;
float P34 = 0;
float P41 = 0;
float P42 = 0;
float P43 = 0;
float P44 = 1;

/* entries of the predicted error covariance matrix of 'x - x_estim' (P_pred) */
//Pos_dot, Pitch and Pitch_gyro
//float P_pred22;
//float P_pred23;
//float P_pred24;
//float P_pred32;
//float P_pred33;
//float P_pred34;
//float P_pred42;
//float P_pred43;
//float P_pred44;
//Pos, Pos_dot, Pitch and Pitch_gyro
float P_pred11;
float P_pred12;
float P_pred13;
float P_pred14;
float P_pred21;
float P_pred22;
float P_pred23;
float P_pred24;
float P_pred31;
float P_pred32;
float P_pred33;
float P_pred34;
float P_pred41;
float P_pred42;
float P_pred43;
float P_pred44;

/* entries of the disturbance covariance matrix (Vd) */
float Vd11 = 0.1;
float Vd12 = 0;
float Vd13 = 0;
float Vd14 = 0;
float Vd21 = 0;
float Vd22 = 0.1;
float Vd23 = 0;
float Vd24 = 0;
float Vd31 = 0;
float Vd32 = 0;
float Vd33 = 0.1;
float Vd34 = 0;
float Vd41 = 0;
float Vd42 = 0;
float Vd43 = 0;
float Vd44 = 0.1;

/* entries of the noise covariance matrix (Vn) */
float Vn11 = 1;
float Vn12 = 0;
float Vn13 = 0;
float Vn14 = 0;
float Vn21 = 0;
float Vn22 = 1;
float Vn23 = 0;
float Vn24 = 0;
float Vn31 = 0;
float Vn32 = 0;
float Vn33 = 1;
float Vn34 = 0;
float Vn41 = 0;
float Vn42 = 0;
float Vn43 = 0;
float Vn44 = 1;

/* entries of the LQR gain (K) */
//float K3 = 79.1914;
//float K4 = 14.0874;
//float K3 = 62.9068;	//original value: 62.9068
//float K4 = 15.4891;	//original value: 9.4891
float K2 = -0.3533;
float K3 = 2.7285;
float K4 = 0.7700;

/* entries of 'tmp' matrix (matrix that temporarily stores values waiting to be used for other operations) */
float tmp11;
float tmp12;
float tmp13;
float tmp14;
float tmp21;
float tmp22;
float tmp23;
float tmp24;
float tmp31;
float tmp32;
float tmp33;
float tmp34;
float tmp41;
float tmp42;
float tmp43;
float tmp44;

/* entries of the matrix A*P*A^(T) (at every iteration of the Kalman Filter it gets computed from scratch) */
float APA11;
float APA12;
float APA13;
float APA14;
float APA21;
float APA22;
float APA23;
float APA24;
float APA31;
float APA32;
float APA33;
float APA34;
float APA41;
float APA42;
float APA43;
float APA44;

/* entries of the matrix C*P_prec*C^(T) (at every iteration of the Kalman Filter it gets computed from scratch) */
float CPC11;
float CPC12;
float CPC13;
float CPC14;
float CPC21;
float CPC22;
float CPC23;
float CPC24;
float CPC31;
float CPC32;
float CPC33;
float CPC34;
float CPC41;
float CPC42;
float CPC43;
float CPC44;

/* entries of the innovation covariance matrix (S) */
//Pitch and Pitch_gyro are measured by the sensors
//float S33;
//float S34;
//float S43;
//float S44;
//Pos and Pitch are measured by the sensors
float S11;
float S13;
float S31;
float S33;

/* entries of the inversed innovation covariance matrix (S^(-1)) */
//Pitch and Pitch_gyro are measured by the sensors
//float S_inv33;
//float S_inv34;
//float S_inv43;
//float S_inv44;
//Pos and Pitch are measured by the sensors
float S_inv11;
float S_inv13;
float S_inv31;
float S_inv33;

/* entries of the output prediction error array (delta_y) */
float delta_y1;
float delta_y2;
float delta_y3;
float delta_y4;

/* scalar variables */
float Pos_pred;									//balancing robot's linear position on the ground predicted by the Kalman filter
float Pos_dot_pred;							//balancing robot's linear velocity on the ground predicted by the Kalman filter
float Pitch_pred;								//balancing robot's angular position predicted by the Kalman filter
float Pitch_gyro_pred;					//balancing robot's angular velocity predicted by the Kalman filter
float Pos_estim = 0;
float Pos_dot_estim = 0;
float error_Pos;
float error_Pos_dot;
float error_Pitch;
float error_Pitch_gyro;
float S_det;										//used to store the determinant of the innovation matrix S
float input_to_wheel_L = 0;			//input sent to the wheels of balancing robot (to be used in Kalman Filter)
float input_to_wheel_R = 0;
float control_signal;
float control_signal_L;
float control_signal_R;
float control_signal_Pitch;
float control_signal_Pos_dot_L;
float control_signal_Pos_dot_R;
float Tcc = 0.001;							//inverse of the frequency of chassis controller (1000 Hz)
float cos_theta;								//cosine of the robot's angular position
float sin_theta;								//sine of the robot's angular position
float a_smc_Pitch;							//value a(x) used for SMC (Sliding Mode Control)
float b_smc_Pitch;							//value b(x) used for SMC (Sliding Mode Control)
float a_smc_Pos;
float b_smc_Pos;
float smc_conv_coeff = 0.1;			//convergence coefficient of the discrete-time sliding mode controller: |S(k+1)| <= smc_conv_coeff * |S(k)|
float ref_Pitch_prec = 0;				//previous reference signal for the robot's angular position
float ref_Pitch_gyro_prec = 0;	//previous reference signal for the robot's angular velocity
float ref_Pitch_succ;						//current reference signal for the robot's angular position
float ref_Pitch_gyro_succ;			//current reference signal for the robot's angular velocity
float ref_Pos_dot_L_prec;
float ref_Pos_dot_R_prec;
float ref_Pos_dot_L_succ;
float ref_Pos_dot_R_succ;
float k2 = 4;										//coeffient for the sliding function: S(k) = e_pitch_gyro(k) + k2*e_pitch(k)
float speedA_value;
float speedB_value;
float kalman_filter_results[4];
float Pitch_estim_L;
float Pitch_estim_R;
float Pitch_gyro_estim_L;
float Pitch_gyro_estim_R;
float Pos_estim_L;
float Pos_estim_R;
float Pos_dot_estim_L;
float Pos_dot_estim_R;


/* variables to contiguously track the position of the motors' encoder */
//int roundsCounter = 0;
//unsigned int completeCircleEncoderAngle = 8192;
//unsigned int currentEncoderAngle;
//unsigned int prevEncoderAngle = 0;
//long long int contiguousEncoderPos = 0;


/* variables for system identification */
int N = 1000;											//number of values that the arrays should contain
float Pitch_measurements[1000];				  //array of pitch position measurements
float Pitch_gyro_measurements[1000];		//array of pitch velocity measurements
float Pitch_estimations[1000];					//array of pitch position estimations
float Pitch_gyro_estimations[1000];			//array of pitch velocity estimations
float white_noise_input[1000];					//array of white noise sent to the wheels
unsigned int i = 0;								//counter for the arrays in which measurements are stored



//white noise for system identification
float white_noise[] = {-0.021462435950044094, -0.43024108996676325, 0.2790327699045845, -0.4975411489863535, -0.0015010968490626903, 0.04093844549228614, 0.22110687726320422, 0.8349236632792012, 0.31153551576182203, 0.8546019929033429, 0.12421344688981367, -0.3063627404066236, -0.6984516548351105, 0.5594927597464849, 0.38916534384834434, 0.4276876343295688, 0.4942859145178569, 0.563481343089424, 0.2134115889313269, -0.5752410285539548, 0.10995688910101996, 0.24297747618667362, 0.6760643447690682, -0.5333641145614156, 0.2550848744550283, 0.512019424211831, 0.039390379148210246, 0.434855618938936, -0.2950447984147478, -0.6792763530889913, 0.3529420941533834, 0.13671241207583323, 1.116787230862336, -0.2755583258632383, -0.14998070772974242, -0.5040896367456458, 0.15028418690778286, -0.2702593637620428, -0.26077901972022605, -0.3294162349454798, -0.03172832163083373, -0.11253964765578783, 0.12686173074111054, 0.3279430623409161, 0.28106022065667063, 0.21363892841991175, 0.4641289997746776, -0.42010708957016085, 0.44497229113095793, -0.03736142621241197, -0.06391821114148362, 0.5946971734662605, -0.761657862106779, 0.34199398597457153, 0.33257328172178036, 0.13906165308408663, 0.4643235072626368, 0.2617093663377662, 0.40192369666297234, 0.17852121518019698, 0.2916798493852892, 0.6181017955175264, 0.5518617704572166, -0.18299172077491258, -0.6902364575187742, -0.047441483446438955, 0.41055977057388704, 0.33929954521475675, 0.3778018636419646, 0.1212986253881651, -0.10476533674581641, 0.25747009782695496, -0.5585297988506998, -0.6678768045264953, 0.28927297507595723, 0.41645632347314365, -0.5561860605265252, 0.18714242959995125, 0.5953597669988372, 0.44482097275292853, 0.6621955568343599, -0.13760319290607875, -0.22153187563378648, 0.3065822894070932, -0.1543826273701252, -0.11956014557638045, -0.0670181449912369, -0.4283726067261972, 0.10387835826630527, -0.280683637478923, 0.11484227184865295, 0.20913069226537534, 1.0318547118538655, -0.1485115336847929, 0.1267933081036115, 0.17495065474785954, -0.6486390667578164, 
0.02525494960323248, 0.1586781962510419, 0.04431593645299289, -0.0006511374418752608, 0.18769741145803473, -0.005947744094402147, -0.5936532421728477, 0.3380495888544384, -0.2619232672734854, -0.28086848438921813, 0.17982967201926622, 0.7052483860486376, -0.5642714284818112, -0.017611764402358756, 0.150582976304606, 0.730190235810039, -0.4775317038195375, 0.4501603259709712, -0.08007114254738938, -0.8535302691008951, 0.1736588904527136, 0.38148147781188163, -0.26678861616635746, 0.05742179915902477, 0.5666269499321159, 0.17382615193501322, 0.22958672990308582, 0.5218421123677215, -0.5383001615543201, 0.010547869601492163, -0.07342329924682915, -0.37133888966051976, -0.1148172603584081, -0.7301157002298804, -1.0490600393969645, -0.4922657815319851, 0.4409522099235213, -0.21566766031459747, 0.41632105984886425, -0.5040086499868891, -0.06541770682056133, -0.18271213006447207, -0.19475266899493987, -0.2677735203884492, 0.08878257453701856, -0.26532317119147253, 0.5873712748098014, 0.1965002531276423, 0.004253863931358057, -0.08921699759084284, -0.22025754515809265, -0.44378878631592267, -0.2262289151910471, -0.8736267329819452, -0.23589917748809153, 0.1639614651304365, -0.29331382363777964, 0.5095145102113071, 0.25320004555877224, 0.12014550409664176, 0.3486910538472998, 
-0.07171032168969797, 0.6941108727062448, 0.08303125560077368, -0.12892793082505835, 0.0991259092424132, 0.32817834106588034, -0.7168814535249, 0.4340432757685655, 0.5360805277647768, 
0.6021700295937219, -0.02178160094036343, -0.11456006134032021, -0.3585909771720713, 0.49059326139871695, -0.16940167012158283, 0.3146683922592162, 0.620765989521113, -0.059077661338398826, 0.08239296566862397, -0.002623062372050433, -0.5339112833971557, -0.20517018528448935, -0.2163685486389385, -0.6053478044702162, -0.09001871853522062, 0.8862079928870457, -0.37413128476844815, 0.12237705003605906, 0.4031183282590767, -0.14342783559062208, 0.5178807180915935, -0.06271617366041216, -0.06817403084056152, -0.14764318809656235, -0.5332692958931794, -0.13601758202681566, -0.35381325190248747, 0.18650425591947828, 0.09272193240591949, -0.23800691000785484, 0.4491831901896981, 0.4242151935573471, -0.243741506388343, -0.13608965139652884, 0.13385226579537737, 0.44943167151395197, 0.16163371255920808, 0.06050229291235946, -0.5507122886018964, -0.19115590602497187, 0.044409727435185675, 0.5631595899736583, -0.015054985959651199, -0.23040924070294141, -0.10890990995234517, -0.6218601251354987, 0.1312628177061701, 0.16247211784990323, -0.13337794113651655, -0.20739810604439884, -0.7114859362551678, -0.24301391069570505, 0.26364556856492055, 0.2447103959696195, 0.2612004610292631, -0.008297532578224657, -0.04674495810572635, -0.22897927564652673, -0.028547860420227156, -0.30617992543668937, 0.11483584458837799, -0.10452597462972904, -0.21177544621781458, 0.08548660676023268, -0.3807739210536145, 0.0830874947246195, 0.3021080210203964, -0.2684215399706805, 0.282685704400291, -0.05659043060184313, 0.6548302727463026, -0.44294101303369593, -0.09125427457906349, 0.5313877308248687, 0.1559178354906339, -0.02211542638133651, 0.17529847485839736, -0.4796462408800348, 0.08664047404885526, 0.2738601135878502, -0.523270010131149, -0.33392417851539535, 0.22695662748511536, 0.22844352748477526, 0.5396277872006049, 0.049739934163368534, 0.11206522809467151, -0.22629674556092638, -0.500943319710234, 0.21439590721137233, 0.20245309861826094, -0.5381061470823684, 0.20592975049524687, 0.05414657026166025, 0.05772322093368935, -0.18587259008203594, -0.4390441211354832, 0.6259947073956543, -0.6800051016221018, 0.33235940088203786, -0.6066221143734665, -0.4011878167753887, 0.6761177110641299, 0.18032506634087384, 0.4583587297528726, 0.16612748997379473, 0.1973916399025342, 0.43894810474862545, 0.5611604429129982, 0.11953576430007729, -0.15230089420791115, 0.47012552032796845, -0.06393474059799113, -0.9190500573855211, -0.6089777938188238, -0.42417208283039165, -0.10925093492249181, 0.33355395214740846, 0.2560032757397617, 0.2075176470231749, -0.5931962633476993, 0.4011465339554331, -0.33400136360281785, -0.16497715604572694, -0.6575873543865146, 0.1738315561828796, -0.11614770104635182, -0.15665097063179304, 0.29600126487768874, 0.07569959633798673, -0.392723669824698, -0.40489958856580677, -0.5389740251678269, 0.29103479142970795, -0.16670939195236378, 0.2638039763091516, 0.3621809945691204, 0.3413279682032147, 0.6328070195202113, -0.3599162433077816, 0.12061808790769382, 0.38206922037969704, -0.015318239401619377, -0.6188469816624559, -0.12256948424663833, 1.231150746757185, -0.07814221511527372, -0.15410699063181085, 0.18356969671903794, -0.3284985515663006, -0.2802600948583832, -0.07634017511413811, -0.8904641284841083, -0.2186512298629429, 0.4743557380892622, 0.35585978965092396, 0.021101257132757508, 0.08699473924360018, -0.24295283794770414, 0.6510414781122147, 0.07592134345237711, -0.1396560368460012, 0.045406339110960856, -0.01769045670877024, 0.15208941995159034, -0.07891140380956635, -0.15658104202030193, 0.05012884580910028, -0.08472306960639613, -0.0944006374373394, -0.2814489927524863, 0.6958914087049486, -0.13498769188047555, -0.13719899295755308, 0.0704693329440184, -1.1335595048949842, -0.11542208295645809, -0.6592467010362141, 0.4685775715132369, -0.1746045760761338, 0.2758761848044216, -0.0035612339777623364, 0.35563194045172297, 0.8255054329122944, 0.030510025424896267, 0.08734356915039221, 0.023972118048575408, -0.0023384596962205107, 0.14052684339686575, 0.35922500904310406, 0.02746034534274774, -0.14156899557889835, -0.22905339075390768, 0.4272924994098145, -0.37574082413960197, 0.010916451008814634, -0.09304586202018356, 0.41448332286639716, 0.10607143793661021, -0.5349954673490419, 0.6159290401245806, 0.6782949100724572, 0.4721104436619814, 0.20967956294482426, 0.370303714763655, 0.636870502293257, -0.5539677202512866, -0.19631780543954278, 0.5461792279043579, -0.11648863190837665, -0.573722868999923, -0.38416149075618733, -0.45937750403560157, -0.09018134532671987, -0.3666951322043114, 0.18916606679793638, 0.2910948579733101, -0.8219405210033724, 0.245616816397763, -0.027212521013060317, -0.31129496106652543, -0.23696345122832208, 0.5410970283409988, 0.03546891571496002, 0.06238640976168406, -0.5928278593773565, 0.35065455474182355, -0.14010300226763978, -0.7552823905033681, -0.3781374006139883, 0.3944927144711632, -0.11452284915620699, 0.07197407665795412, -0.4059751861893974, 0.37176237329959394, 0.1826078416998793, -0.4252977267395716, -0.4093769193954159, -0.08595068745520804, -1.2822370396715885, -0.25811974878477456, -0.4208635688659844, 0.20611023492677114, -0.5004376174637704, -0.26575941827241145, -0.07690501878241393, -0.19620521180305656, 0.14829890959382372, 0.3954526969611549, -0.30583276835838724, -0.11132062197287954, -0.20890546502129528, 0.3860070139147685, 0.16750955154722844, 0.6561794277973224, -0.40084656669803015, 0.3999451793289485, 0.24775021009396825, 0.36246861662383534, -0.01527807279277012, -0.10192960684154873, 0.22924060718919717, 0.5039460603334865, -0.2554285420089397, 0.33803178848814297, 0.5859277758793244, -0.42556366733251133, -0.0989360011210131, -0.6080278910504782, -0.6210813318390315, 0.12186298206044699, 0.17499368970420975, -0.17779421004287232, 0.0072768865376847056, -0.3699477710340906, 0.10709154410968338, -0.3018471083951858, 0.7222645110634643, -0.5238782043678462, 0.38685415904426673, 0.20963471656862925, -0.07240460244304468, 0.44017216961884115, 0.4147476826644016, 0.12025374663468431, 0.17489228092890707, -0.26503892589618777, 0.6347022811308078, 0.38815533223813103, -0.13682020293441075, 0.23072854786197625, 0.2887199264639044, -0.21003519159673265, 0.1247646932808533, -0.7249089796638569, 1.2350160998494912, 0.7636670448183147, -0.3096092031928368, -0.757717266207036, 0.3650110960028309, -0.0025224005460567525, -0.5693949114025125, 0.593047826891214, 0.20692006309289762, 
-0.2293665036529868, 0.20955994491655405, -0.4759526474203411, 0.2298753839525357, 0.46730249443215155, 0.42893177667975624, 0.00979732874618227, -1.3006153947299604, 0.6467632106008838, -0.3250584721684623, 0.5156010054447563, 0.006911748480375863, -0.019611348084465824, -0.12137353965989049, 0.2886770126673916, -0.008385215261792764, -0.1355152815828766, -0.15295197436661012, -0.02445294151448909, -0.05302133707859272, 0.7409081263797956, -0.10385758581688603, -0.21543794725649695, -0.09888810582685438, 0.11067190422009099, 0.20586386281414504, 0.07741075204181586, 0.38957104109532414, 0.4937628960264464, -0.22185507474087973, -0.31639266828136753, 0.15710697841814633, 0.2107908996011085, 0.3823563577377314, -0.08897211213263888, -0.2875643413536095, -0.2752777005747801, 0.50117403934106, -0.5949800680851344, 0.1439354325838795, 0.6695600361822093, -0.12440243183805333, -0.2773382125483165, -0.010798941077636823, 0.44754759801174315, 0.2670119904736533, -0.4906721912088908, 0.12491174605123004, 0.08055857375334881, -0.15340852883101116, -0.4096309311853137, -0.19550781716087187, -0.496514870814674, 0.29711065864323777, 0.03218567592234178, 0.023720701179794235, 0.21014228699292323, 0.005396340142614221, -0.09054752656989194, -0.6225264923066187, -0.2609457399194491, -0.12770120461630383, -0.24824099424334578, -0.08837547981690591, -0.3752386534602926, -0.22764362147127715, -0.13996075493481727, -0.2702675243843321, 0.5352264119911261, -0.2205721386530648, 0.13388083235214907, -0.1433113140337636, -0.2296148480738705, 0.3060756801335304, 0.06488906913762532, 0.12341169321605956, 0.4297281972446054, -0.13779595080152693, 0.2853638295116418, 0.24837504189313064, 0.22410917849656709, -0.6974798424246341, -0.5342134816373191, 0.22241477663560638, 0.3511718377726969, 0.3089405281174174, 0.15046359829039557, 0.6145659027519557, -0.9860593714186519, 0.10407987766636782, -0.5639846729270662, 0.07427354283042543, -0.1130016256409625, 0.1750472623141921, 0.21786244850848374, 0.4733630433772786, 0.06337123639782992, 0.01940137220479672, -0.3028817740072795, 0.2379374518066849, 0.6815224000897881, 0.1418091594736626, -0.17009424147316643, -0.2459274580531059, -0.10024317081857091, -0.27034870844119285, -0.3270323797094187, -0.18759972878850237, 0.25845276505247805, 0.28378145295349655, -0.2061195461150498, -0.19920544634657575, -0.36489179271545424, -0.5297649163565209, -0.05741275440709109, 0.28129246592340856, -0.30952831313923695, -0.39559827668562675, -0.27293878743177524, 0.26801959008209403, -0.02061362031597673, -0.042802412548740086, 0.5271351963299676, 0.3203540441473942, 0.7682867666789193, -0.18761713280290723, 0.00532415771221576, -0.04350028023898531, -0.04638333896412504, 0.05077255642120047, -0.3442420125614121, 0.34655737406643605, -0.3637111064490589, -0.5070766739332, 0.18301816867885976, 0.5159859967620303, -0.4159220557965979, 0.10847204704623042, 0.31677980376125126, -0.04497131237570124, 0.046700097149974945, -0.4810805530730293, -0.316975383832514, -0.22982663499833464, -0.0988087614079114, -0.15768379917910913, -0.5861394705750954, 0.3207906290364247, 0.23563807811218762, 0.15351933748622948, -0.10186318852856445, -0.45072704288345933, 0.006238905542339295, 0.04260650370558928, -0.07243099995914856, -0.46610752338968375, 0.37237467303884403, 0.23403366262660086, -0.195430099845587, -0.21367438100147185, 0.2869711838567572, -0.2528755670056722, -0.3457086143975602, -0.16420941294136232, 0.018018051680937574, -0.1983720484494032, 0.44689979920073264, 0.4224672741073663, 0.7761961374746983, 0.5009381101028809, -0.14773698151557577, -0.7699952563133107, 0.9768435254285954, 0.6114242010288431, -0.6313952107594983, 0.7981999068443366, 0.6634175998814151, -0.01224250207411384, 0.17008310023493736, 1.0045740659385225, 0.0713684886848704, 0.6115126324279541, -0.24965111066333795, -0.18295782280812717, 0.306657036091841, -0.1299871075589057, -1.0175053134103995, -0.45835588817232625, -0.10442252386474178, -0.6156121896625978, 0.475298102060508, -0.13668408144325225, -0.2667857006798124, 0.20300945470131443, -0.3118975944306643, -0.7008147935876162, -0.26267563754256873, 0.4346485867977234, 0.21103053408326336, 0.3009054001346302, 0.20532780110106838, 
0.3416895950602687, -0.3537943166405581, 0.4123635476464691, 0.9970135089042191, -0.6589367321881675, -0.6922427235184935, -0.4219057239997872, -0.21687740427493896, -0.055278057786202844, -0.01593794012849185, -0.585735836875413, -0.10059997728967557, -0.3023952754177998, 0.7829785110871792, 0.3579757557480086, 0.669922189752717, 0.023827029120423726, 0.41830705214297237, -0.03795813721789824, 0.09852385555170257, -0.7523540687770212, 0.01629091145182559, -0.05481706230929036, -0.5577348312221555, 0.18236190486394876, -0.20496160903225402, -0.09335004867683806, -0.33332337166891035, -0.5852236376735928, -0.8710047158787564, 0.41094739992221874, -0.4201904488759762, 0.20748649620865034, 0.5724200413451669, -0.455168896121432, 
0.6525853373221312, -0.5837393072637814, -1.2276999854385564, -0.6293566880466259, 1.0348822241830484, -0.4910651732258338, 0.25258192850892386, -0.18889606472013323, -0.17430988996021882, -0.0549232280403156, 0.504514961309655, 0.10460469780306676, 0.056228507166514986, 0.5527635819590261, -0.1489457552235061, -0.071706296567289, 0.5721789149028867, -0.016854839146508423, 0.7027583527254126, -0.13286352341961735, 0.46934086700693256, -0.8845415525329904, -0.4522897569056323, 0.029834776708499607, -0.4006699223120146, 0.034449605043270874, -0.12744074774475636, 0.17156036314686818, 0.8590078168924308, -0.3629959977923761, -0.5044623847520243, -0.09997809621443719, 0.7147069880159558, -0.5955150519559212, 0.6091107833107745, 0.239574506007266, -0.1748750183246892, 0.4631218792942301, -0.18014112869202104, -0.47402390801328576, 0.11425809693119122, 0.1941367529449305, -0.5926695401179246, 0.05949205963109891, 0.14673736754499564, 0.46548496709718234, -0.24417219147629543, 0.15247966037933816, -0.41922051740549415, 0.4396905236282687, -0.4719557919219492, 0.2124388388455185, 0.441527996803146, 0.15306072673105384, -0.07738041793348356, -0.5590117299192119, 0.06315877365890753, 0.35863507571669256, 0.31547166456907455, 0.18445916685304453, -0.30277259116319427, 0.35597973783521414, 0.5663756088502641, -0.10326911109165536, -0.0802618099326308, -0.27786294257619065, 0.2663447058382883, 0.7274780631643152, 0.03415633101286441, 0.468127656602967, 0.43186957001333826, 0.09019908592200437, 0.16457201169343233, 0.498922932285085, -0.291506665120255, -0.12674377564269362, 0.18142370082373271, 0.2000846063677497, 0.2687830624993741, -0.17957356093889762, 0.08324133184201164, 0.48968264903707165, -0.5276037577997041, -0.18244496672050384, -0.2287614274262483, -0.108119515323995, 0.24490796557534328, 0.2170697385773256, 0.39119340668443725, -0.520678952148485, 0.11438934384107291, -0.07028884194964681, -0.4725568348186391, 0.28856905621333534, 0.31461846996671805, 0.795415823388339, 0.11495980647399764, 0.036510291451467516, 0.1151514958794824, -0.4816380631173807, -0.059106427029594656, -0.4359027606610226, 0.37802971777369954, -0.02533001254087011, 0.09767495757290562, 0.25890418767216505, 0.9205395167974685, -0.6447082257913914, -0.15526300389578832, 0.49813870007663363, 0.3257593594741492, 0.6246567473919823, 0.8164324835078495, -0.03439823573327542, 0.02224983965194142, 0.02046557357567401, -0.12258727045973933, 0.19419825446256647, -0.14505360989459054, -0.0441821795793222, 0.17532339063177693, -0.23851031778776563, 0.1781081883152602, -0.03951448890078148, -0.13743003891973413, 1.2457534827518872, 0.008349242667393437, 0.42787865100653044, -0.7592480758625627, 0.5433628379368707, -0.06618455917164583, 0.2825889699736927, 0.16555997575813064, -0.5037898407560246, -0.15521194820342188, -0.19962074730459722, -0.3660354825135371, -0.12744716102411352, 0.4580306528461782, 0.09770143827710659, -0.32671178291990366, -0.09022593628211384, 0.1349066920621684, -0.10150070340091438, -0.611167000453129, -0.35301701459555773, 0.5407316001773416, -0.09499819714764965, 0.18901617701521012, 0.01971873539918041, -0.4707060645358392, 0.5703293038925076, 0.2541470594174767, 0.14011270151725008, -0.3979185225797726, -0.31656871504993445, -0.10015711046551723, -0.22150065691714801, 0.3970155779872061, 0.09870457576631342, -0.6153868360044406, -0.4416009818917124, 0.5405509893989298, -0.5713984219894395, 0.2550867222818003, -0.4704658856935228, -0.2865895906350817, -0.26994735174629536, 0.4880483688683221, 0.2912637165011586, 0.5925163902407066, 0.34737901710912356, -0.013534957307509142, 0.4589724011146116, -0.11605873257501863, 0.6779231622757336, 0.18498657788985262, 0.4751262165715801, -0.37295478987732206, -0.4214241954984008, -0.22501566281118301, 0.5059877812538107, -0.09830113934951001, -0.2740016523021007, -0.06996551618853858, 0.4492999900154218, -0.3298312282989186, 0.19688551274638835, -0.03601097445351698, -0.10125001233642109, 0.009659867454333781, -0.04109453763934279, -0.635561606390207, -0.04723607113935962, -0.04849955531420773, 0.35505070264147304, 0.0516835041253666, -0.4491115389681051, -0.20825010316052808, -0.24567202868618665, 0.1301855708383491, 0.1382041692850301, -0.7832328083059619, 0.31233573706639056, -0.45818890150953245, 0.4237361326330613, -0.43249267098057526, -0.1270966394843504, 0.018643909306179336, 0.4931745836235739, 0.3920730316337621, 0.2051500798400775, -0.29561841930157123, 0.1436033346959892, -0.24466150529561556, -0.10041168836476172, 0.24714100424741262, 0.3282023812442077, -0.05981430665532422, 0.2718904080907127, 0.23442606439980979, 0.2800902174126318, -0.4048103772307684, 0.7390207355801279, 0.5732680405296872, -0.22005510376556617, -0.34935083214082285, 0.0964349939437318, 
-0.17505112611744514, -0.5668990010693972, -0.18185732818878975, -0.3495643370181467, -0.3556167650300933, -0.023543152417816928, -0.24456567404313267, 0.32705600835689874, 0.5315091395396957, 0.022427674049619373, -0.6104893484530556, -0.1913066868876083, -0.18039468948156867, 0.5661628926440123, -0.5352376625359078, -0.19588146801745132, -0.2532765378663399, 0.0967705229996401, -0.4012384863111935, -0.706914857910564, 0.05966134372829484, -0.00015558700116787913, -0.09022735847988719, -0.32047681451148946, 0.18916467603064074, 0.31504095936661203, 0.20402307347831827, 0.6966122900206575, 0.3781169154596693, -0.01085837657376334, -0.25130242078565285, 0.039561433216221825, -0.1445314228575015, -0.6451881336206475, 0.04658952559092217, -0.16769202967948849, 0.08882780939994017, 0.5451348782266997, -0.40509181344009076, -0.22517110087374237, -0.16071828130046523, 0.13410622934456148, 0.2730680748314408, 0.07143532573568875, -0.7621533657359719, -0.506582539710467, 0.26172814814672885, 0.1958021538085421, -0.1275973355557012, -0.16503968942392333, 0.23730752945390396, 0.9888857674915198, -1.3696982560997437, -0.032028451286668244, -0.7925778326063257, 0.3465861290272747, -0.1371176050930432, -0.41966256100346916, -0.06453129738238146, -0.5669726709610775, 0.2118916947439956, 0.11741546846415496, 0.07924572046481533, -0.19916272969716087};





float out_speedL=0;
float out_speedR=0;
int16_t speedL=0;
int16_t speedR=0;
	
int16_t	mantainPosEncoderL = 0;				//control signal to make the left wheel mantain its position on the ground
int16_t	mantainPosEncoderR = 0;				//control signal to make the right wheel mantain its position on the ground

GimbalPID ChassiPitchPID;
float CMbalanceVal=0;
/*-------------  底盘控制循环  -------------*/
void CMControlLoop(void)
{

    CM_Switch_Moni();
    if(remoteState == PREPARE_STATE)
    {
        CMControlOut(0,0,0,0);
    }
    else if(remoteState == NORMAL_REMOTE_STATE)
    {
      //CMFollowVal = followValCal(0);
      //move(RC_Ex_Ctl.rc.ch0/10.24,RC_Ex_Ctl.rc.ch1/5.12,CMFollowVal/*0.5f*(RC_Ex_Ctl.rc.ch2)*/);
			//CMbalanceVal = caculate_balance(0.15*57.3);
			//move_balance(RC_Ex_Ctl.rc.ch1/5.12,0.5f*(RC_Ex_Ctl.rc.ch2),CMbalanceVal);
			
			/* NOTE: Kalman Filter has to be executed before than the LQR controller (think about the control system's block diagram) */
			//kalman_filter_update(input_to_wheels, Pitch - 0.28, Pitch_gyro);				// update the estimation of the balancing robot state
			kalman_filter_nonlinear_update(input_to_wheel_L, continuous_current_position_201*1, Pitch - 0.31);	// update the estimation of the balancing robot state
			Pos_estim_L = kalman_filter_results[0];
			Pos_dot_estim_L = kalman_filter_results[1];
			Pitch_estim_L = kalman_filter_results[2];
			Pitch_gyro_estim_L = kalman_filter_results[3];
			kalman_filter_nonlinear_update(input_to_wheel_R, continuous_current_position_202*1, Pitch - 0.31);
			Pos_estim_R = kalman_filter_results[0];
			Pos_dot_estim_R = kalman_filter_results[1];
			Pitch_estim_R = kalman_filter_results[2];
			Pitch_gyro_estim_R = kalman_filter_results[3];
			Pitch_estim = (Pitch_estim_L + Pitch_estim_R) / 2;
			Pitch_gyro_estim = (Pitch_gyro_estim_L + Pitch_gyro_estim_R) / 2;
			//move_balance(RC_Ex_Ctl.rc.ch1,RC_Ex_Ctl.rc.ch0,CMbalanceVal);															// LQR controller
			sliding_mode_controller(RC_Ex_Ctl.rc.ch1,RC_Ex_Ctl.rc.ch0,CMbalanceVal);
    }
    else if(remoteState == STANDBY_STATE )
    {
        CMStop();
    }
    else if(remoteState == ERROR_STATE )
    {
        CMStop();
    }
    else if(remoteState == KEY_REMOTE_STATE )
    {
				CMStop();
    }
    else if(remoteState == VIEW_STATE )
    {
				CMStop();
    }


}


float NowPosition_b = 0;
float caculate_balance(float Setposition){
	// Setposition is measured in rad
	float balanceVal = 0;
	float NowPosition = Pitch*57.3;
	
	float NowSpeed = Pitch_gyro*57.3;
//	if (abs(NowPosition)<20){
//		PID_SetGains(&ChassiPitchPID.Position,pp*(1-abs(NowPosition)/20.0),pi,pd);
//	}else{
//		return 0;
//	}
	balanceVal = PID_ControllerDriver(&ChassiPitchPID.Position,Setposition,NowPosition);
//	balanceVal=PID_ControllerDriver(&ChassiPitchPID.Speed,balanceVal/5.0f,NowSpeed);
	return balanceVal;
//	history[history_pos]=PID_ControllerDriver(&ChassiPitchPID.Speed,balanceVal/5.0f,NowSpeed);
//	if (history_pos<49){
//		history_pos+=1;
//	}
//	else{
//		history_pos=0;
//	}
//	NowPosition_b=0;
//	for (int16_t i=0;i<50;i++){
//		//NowPosition +=history[i];
//		NowPosition_b +=history[i];
//	}
//	balanceVal = NowPosition_b/50;
//	return balanceVal;
		
}

//float sum_Pitch_estim = 0;
//float sum_Pitch_gyro_estim = 0;
float history[10]={0,0,0,0,0,0,0,0,0,0};
int16_t history_pos=0;

void move_balance(int16_t speedY, int16_t rad,int16_t balance){
//	float max_speed=0;
//	speedL = speedY + balance + rad;
//	speedR = -speedY - balance + rad;
//	
//	if(fabs(speedL)>max_speed)
//        max_speed=fabs(speedL);
//	if(fabs(speedR)>max_speed)
//			max_speed=fabs(speedR);
//	
//	if(max_speed>max_output_speed)
//	{
//		speedL*=max_output_speed/max_speed;
//		speedR*=max_output_speed/max_speed;
//	}
//	float now_Pitch =0;
//	if (abs(Pitch)>0.01){
//		now_Pitch=Pitch;
//	}
	
//	if (speedY == 0 && rad == 0) {
//		currentPosL = current_position_201;
//		if (precPosL - currentPosL > 4000) {
//			counterRoundsL += 1;
//		}
//		contiguousPosEncoderL = 
//	}
//	else {
//		
//		mantainPosEncoderL = 0;
//		mantainPosEncoderR = 0;
//	}
//	
//	current_position_202
	
	
	
	// LQR control algorithm
	error_Pitch = (0 - Pitch_estim);				// I deleted the *57.3, because the Pitch and Pitch_gyro have to influence the LQR as much as Pos_dot
	if (speedY != 0) {
		
		error_Pitch += (-speedY/1024.0)*0.1221;			// sets the Pitch target in order to go forward/backward
	}
	else if (rad == 0) {
		
//	error_Pitch += continuous_current_position_201*0.0005;			// sets the Pitch target in order to mantain the linear position on the ground
	}
	
	error_Pitch_gyro = (0 - Pitch_gyro_estim);
	
//	// Huber loss for Pitch
//	if (error_Pitch >= 0) {
//		if (error_Pitch < 0.12) error_Pitch *= error_Pitch;
//	}
//	else {
//		if (-error_Pitch < 0.12) error_Pitch *= error_Pitch;
//	}
//	
//	// Huber loss for Pitch_gyro
//	if (error_Pitch_gyro >= 0) {
//		if (error_Pitch_gyro < 0.12) error_Pitch_gyro *= error_Pitch_gyro;
//	}
//	else {
//		if (-error_Pitch_gyro < 0.12) error_Pitch_gyro *= error_Pitch_gyro;
//	}
	
	control_signal = error_Pitch*K3 + error_Pitch_gyro*K4;
	
	if (speedY == 0) {
		
		// enable the control of the linear velocity on the ground
		error_Pos_dot = (0 - Pos_dot_estim);
		control_signal += error_Pos_dot*K2;
		
		if (rad == 0) {
			
			// enable the control of the linear position on the ground
//			control_signal += continuous_current_position_201*0.005;
		}
		//else contiguousEncoderPos = 0;
	}
	//else contiguousEncoderPos = 0;
	
	control_signal *= 10000;
	
	speedL = control_signal;
	
	
	//theta reference without KF: 0.27
	//theta reference with KF: 0.28
//	speedL = 6*((0.28+(-speedY/1024.0)*0.1221-Pitch)*57.3*K3+(0-Pitch_gyro)*57.3*K4);		// LQR control algorithm
//	if (0.265 >= Pitch) {
//		if (0.265-Pitch < 0.12) speedL *= 1.2;
//	}
//	else {
//		if (Pitch-0.265 < 0.12) speedL *= 1.2;
//	}
//	speedL = MotorCurrentLegalize(speedL,5000);
	
	speedR = -speedL;

	CMControlOut(speedL+rad*2,speedR+rad*2,0,0);
	//CAN1_Send_Bottom(speedL,speedR,0,0); //to send the control signals directly to the wheels motors
}


void sliding_mode_controller(int16_t speedY, int16_t rad,int16_t balance){

//	current_position_202
	
	cos_theta = cos(Pitch_estim);
	sin_theta = sin(Pitch_estim);
	
	ref_Pitch_succ = 0 + (-speedY/1024.0)*(10*3.1415/180);					//0.1221 rad = (7 degrees)*pi/180 <- MAX inclination of the robot's angular position
	ref_Pitch_gyro_succ = 0;
	
	a_smc_Pitch = ((m_top*l*g*sin_theta)/(I+m_top*l*l) + ((m_top*l*cos_theta)*(-b*Pos_dot_estim - m_top*l*Pitch_gyro_estim*Pitch_gyro_estim*sin_theta))/((I+m_top*l*l)*(M_bottom+m_top))) / (1 - (m_top*l*cos_theta)*(m_top*l*cos_theta)/((I+m_top*l*l)*(M_bottom+m_top)));
	b_smc_Pitch = ((2*m_top*l*cos_theta)/((I+m_top*l*l)*(M_bottom+m_top)*r)) / (1 - (m_top*l*cos_theta)*(m_top*l*cos_theta)/((I+m_top*l*l)*(M_bottom+m_top)));
	
	control_signal_Pitch = (ref_Pitch_gyro_succ - Pitch_gyro_estim - Tcc*a_smc_Pitch + k2*(ref_Pitch_succ - Pitch_estim - Tcc*Pitch_gyro_estim) - smc_conv_coeff*((ref_Pitch_gyro_prec - Pitch_gyro_estim) + k2*(ref_Pitch_prec - Pitch_estim))) / (Tcc*b_smc_Pitch);
	
	ref_Pitch_prec = ref_Pitch_succ;
	ref_Pitch_gyro_prec = ref_Pitch_gyro_succ;
	
	
	
	//SMC for Pos_dot
	Pos_dot_estim_L = estimated_speed_201;
	Pos_dot_estim_R = estimated_speed_202;
	
	ref_Pos_dot_L_succ = - Pos_dot_estim_L*0.3;
	ref_Pos_dot_R_succ = - Pos_dot_estim_R*0.3;
	
	a_smc_Pos = (-b*(I + m_top*l*l)*Pos_dot_estim + m_top*m_top*l*l*g*cos_theta*sin_theta - m_top*l*(I + m_top*l*l)*Pitch_gyro_estim*Pitch_gyro_estim*sin_theta) / ((I - m_top*l*l)*(M_bottom + m_top) - (m_top*l*cos_theta)*(m_top*l*cos_theta));
	b_smc_Pos = (2/r) / ((I - m_top*l*l)*(M_bottom + m_top) - (m_top*l*cos_theta)*(m_top*l*cos_theta));
	
	control_signal_Pos_dot_L = (ref_Pos_dot_L_succ - Pos_dot_estim_L - Tcc*a_smc_Pos - smc_conv_coeff*(ref_Pos_dot_L_prec - Pos_dot_estim_L)) / (Tcc*b_smc_Pos);
	control_signal_Pos_dot_R = (ref_Pos_dot_R_succ - Pos_dot_estim_R - Tcc*a_smc_Pos - smc_conv_coeff*(ref_Pos_dot_R_prec - Pos_dot_estim_R)) / (Tcc*b_smc_Pos);
	
	ref_Pos_dot_L_prec = ref_Pos_dot_L_succ;
	ref_Pos_dot_R_prec = ref_Pos_dot_R_succ;
	
	
	
	if ((speedY < 0 && Pos_dot_estim > 0) || (speedY > 0 && Pos_dot_estim < 0)) {
		control_signal_Pos_dot_L *= 100;
		control_signal_Pos_dot_R *= 100;
	}
	
	//control_signal_balance = 0;
	control_signal_L = control_signal_Pitch + 0.1*control_signal_Pos_dot_L;	//0.01
	control_signal_R = control_signal_Pitch + 0.1*control_signal_Pos_dot_R;	//0.01
	
	control_signal_L *= 25;		//35
	control_signal_R *= 25;		//35
	
	if (speedY == 0 && rad == 0) {
		control_signal_L *= 1.3;	//1.3
		control_signal_R *= 1.3;	//1.3
	}
	
	speedL = control_signal_L;
	speedR = -control_signal_R;

	CMControlOut(speedL+rad*2,speedR+rad*2,0,0);
	//CAN1_Send_Bottom(speedL,speedR,0,0); //to send the control signals directly to the wheels motors
}


/***************************************************************************************
*Name     	: kalman_filter_update
*Function 	: estimates the angular position and velocity of the robot by its inputs and outputs
*Input    	: u (input to the robot at time k-1), y3 (robot's pitch position at time k), y4 (robot's pitch velocity at time k)
*Output   	: none (the function just updates the values of Pitch_estim and Pitch_gyro_estim, which are estimations of pitch position and velocity of the robot, respectively)
*Description: it implements a state-of-the-art algorithm to solve iteratively the Riccatti equation, hence to compute Kf (the Kalman Filter gain matrix) and to estimate the robot's state
****************************************************************************************/
//void kalman_filter_update(int16_t u, float y3, float y4)
//{
//	
//	/*Step 1: Prediction*/
//	// state prediction: x_pred(k) = A*x_estim(k-1) + B*u(k-1)
////	Pitch_pred = (A33*Pitch_estim + A34*Pitch_gyro_estim) + (B3*u);
////	Pitch_gyro_pred = (A43*Pitch_estim + A44*Pitch_gyro_estim) + (B4*u);
//	Pos_dot_pred = (A22*Pos_dot_estim + A23*Pitch_estim + A24*Pitch_gyro_estim) + (B2*u);
//	Pitch_pred = (A32*Pos_dot_estim + A33*Pitch_estim + A34*Pitch_gyro_estim) + (B3*u);
//	Pitch_gyro_pred = (A42*Pos_dot_estim + A43*Pitch_estim + A44*Pitch_gyro_estim) + (B4*u);
//	Pitch_gyro_pred = Pitch_gyro_pred*0.0001;
//	
//	//Taylor series of consine and sine of the previously estimated robot's angular position
////	cos_theta = 1 - (Pitch_estim*Pitch_estim)/2 + (Pitch_estim*Pitch_estim*Pitch_estim*Pitch_estim)/24 - (Pitch_estim*Pitch_estim*Pitch_estim*Pitch_estim*Pitch_estim*Pitch_estim)/720;
////	sin_theta = Pitch_estim - (Pitch_estim*Pitch_estim*Pitch_estim)/6 + (Pitch_estim*Pitch_estim*Pitch_estim*Pitch_estim*Pitch_estim)/120 - (Pitch_estim*Pitch_estim*Pitch_estim*Pitch_estim*Pitch_estim*Pitch_estim*Pitch_estim)/5040;
////  cos_theta = cos(Pitch_estim);
////  sin_theta = sin(Pitch_estim);
////	Pitch_pred = Pitch_estim + Tcc*Pitch_gyro_estim;
////	Pos_dot_pred = Pos_dot_estim + Tcc*(-b*(I+m_top*l*l)*Pos_dot_estim + m_top*m_top*l*l*g*cos_theta*sin_theta - m_top*l*(I+m_top*l*l)*Pitch_gyro_estim*Pitch_gyro_estim*sin_theta + (2/r)*u) / ((I+m_top*l*l)*(M_bottom+m_top) - (m_top*l*cos_theta)*(m_top*l*cos_theta));
////	Pitch_gyro_pred = Pitch_gyro_estim + Tcc*((m_top*l*g*sin_theta)/(I+m_top*l*l) + ((m_top*l*cos_theta)*(-b*Pos_dot_estim - m_top*l*Pitch_gyro_estim*Pitch_gyro_estim*sin_theta))/((I+m_top*l*l)*(M_bottom+m_top)) + ((2*m_top*l*cos_theta)/((I+m_top*l*l)*(M_bottom+m_top)*r))*u) / (1 - (m_top*l*cos_theta)*(m_top*l*cos_theta)/((I+m_top*l*l)*(M_bottom+m_top)));
//	
//	
//	
//	// compute the matrix A*P(k-1)*A^(T) and store it in the matrix 'tmp'
////	tmp33 = A33*P33 + A34*P43;
////	tmp34 = A33*P34 + A34*P44;
////	tmp43 = A43*P33 + A44*P43;
////	tmp44 = A43*P34 + A44*P44;
//	tmp22 = A22*P22 + A23*P32 + A24*P42;
//	tmp23 = A22*P23 + A23*P33 + A24*P43;
//	tmp24 = A22*P24 + A23*P34 + A24*P44;
//	tmp32 = A32*P22 + A33*P32 + A34*P42;
//	tmp33 = A32*P23 + A33*P33 + A34*P43;
//	tmp34 = A32*P24 + A33*P34 + A34*P44;
//	tmp42 = A42*P22 + A43*P32 + A44*P42;
//	tmp43 = A42*P23 + A43*P33 + A44*P43;
//	tmp44 = A42*P24 + A43*P34 + A44*P44;
//	// now 'tmp' stores the matrix A*P(k-1), so we can compute tmp*A^(T)
////	APA33 = tmp33*A33 + tmp34*A34;
////	APA34 = tmp33*A43 + tmp34*A44;
////	APA43 = tmp43*A33 + tmp44*A34;
////	APA44 = tmp43*A43 + tmp44*A44;
//	APA22 = tmp22*A22 + tmp23*A23 + tmp24*A24;
//	APA23 = tmp22*A32 + tmp23*A33 + tmp24*A34;
//	APA24 = tmp22*A42 + tmp23*A43 + tmp24*A44;
//	APA32 = tmp32*A22 + tmp33*A23 + tmp34*A24;
//	APA33 = tmp32*A32 + tmp33*A33 + tmp34*A34;
//	APA34 = tmp32*A42 + tmp33*A43 + tmp34*A44;
//	APA42 = tmp42*A22 + tmp43*A23 + tmp44*A24;
//	APA43 = tmp42*A32 + tmp43*A33 + tmp44*A34;
//	APA44 = tmp42*A42 + tmp43*A43 + tmp44*A44;
//	
//	// forecast error covariance: P_pred(k) = A*P(k-1)*A^(T) + Vd
////	P_pred33 = APA33 + Vd33;
////	P_pred34 = APA34 + Vd34;
////	P_pred43 = APA43 + Vd43;
////	P_pred44 = APA44 + Vd44;
//	P_pred22 = APA22 + Vd22;
//	P_pred23 = APA23 + Vd23;
//	P_pred24 = APA24 + Vd24;
//	P_pred32 = APA32 + Vd32;
//	P_pred33 = APA33 + Vd33;
//	P_pred34 = APA34 + Vd34;
//	P_pred42 = APA42 + Vd42;
//	P_pred43 = APA43 + Vd43;
//	P_pred44 = APA44 + Vd44;
//	
//	/*Step 2: Update predictions*/
//	// compute the matrix C*P_pred(k)*C^(T) and store it in the matrix 'tmp'
////	tmp33 = P_pred33*C33 + P_pred34*C34;
////	tmp34 = P_pred33*C43 + P_pred34*C44;
////	tmp43 = P_pred43*C33 + P_pred44*C34;
////	tmp44 = P_pred43*C43 + P_pred44*C44;
//	tmp23 = P_pred22*C32 + P_pred23*C33 + P_pred24*C34;
//	tmp24 = P_pred22*C42 + P_pred23*C43 + P_pred24*C44;
//	tmp33 = P_pred32*C32 + P_pred33*C33 + P_pred34*C34;
//	tmp34 = P_pred32*C42 + P_pred33*C43 + P_pred34*C44;
//	tmp43 = P_pred42*C32 + P_pred43*C33 + P_pred44*C34;
//	tmp44 = P_pred42*C42 + P_pred43*C43 + P_pred44*C44;
//	// now 'tmp' stores the matrix P_pred(k)*C^(T), and we can compute C*tmp
////	CPC33 = C33*tmp33 + C34*tmp43;
////	CPC34 = C33*tmp34 + C34*tmp44;
////	CPC43 = C43*tmp33 + C44*tmp43;
////	CPC44 = C43*tmp34 + C44*tmp44;
//	CPC33 = C32*tmp23 + C33*tmp33 + C34*tmp43;
//	CPC34 = C32*tmp24 + C33*tmp34 + C34*tmp44;
//	CPC43 = C42*tmp23 + C43*tmp33 + C44*tmp43;
//	CPC44 = C42*tmp24 + C43*tmp34 + C44*tmp44;
//	
//	// innovation covariance matrix: S(k) = C*P_pred(k)*C^(T) + Vn
//	S33 = CPC33 + Vn33;
//	S34 = CPC34 + Vn34;
//	S43 = CPC43 + Vn43;
//	S44 = CPC44 + Vn44;
//	
//	// compute the inverse of the 2x2 innovation matrix S(k)^(-1)
//	S_det = S33*S44 - S34*S43;
//	S_inv33 = S44/S_det;
//	S_inv34 = -S34/S_det;
//	S_inv43 = -S43/S_det;
//	S_inv44 = S33/S_det;
//	
//	// compute Kalman Filter gain matrix: Kf(k) = P_pred(k)*C^(T)*S(k)^(-1)
////	Kf33 = tmp33*S_inv33 + tmp34*S_inv43;
////	Kf34 = tmp33*S_inv34 + tmp34*S_inv44;
////	Kf43 = tmp43*S_inv33 + tmp44*S_inv43;
////	Kf44 = tmp43*S_inv34 + tmp44*S_inv44;
//	Kf23 = tmp23*S_inv33 + tmp24*S_inv43;
//	Kf24 = tmp23*S_inv34 + tmp24*S_inv44;
//	Kf33 = tmp33*S_inv33 + tmp34*S_inv43;
//	Kf34 = tmp33*S_inv34 + tmp34*S_inv44;
//	Kf43 = tmp43*S_inv33 + tmp44*S_inv43;
//	Kf44 = tmp43*S_inv34 + tmp44*S_inv44;
//	
//	// error between prediction's output and actual output: delta_y(k) = y(k) - C*x_pred(k)
//	delta_y3 = y3 - (C32*Pos_dot_pred + C33*Pitch_pred + C34*Pitch_gyro_pred);
//	delta_y4 = y4 - (C42*Pos_dot_pred + C43*Pitch_pred + C44*Pitch_gyro_pred);
//	
//	// state estimation by means of 'a posteriori' correction of the state prediction: x_estim(k) = x_pred(k) + Kf*delta_y(k)
////	Pitch_estim = Pitch_pred + (Kf33*delta_y3 + Kf34*delta_y4);
////	Pitch_estim = Pitch_estim*10;
////	Pitch_gyro_estim = Pitch_gyro_pred + (Kf43*delta_y3 + Kf44*delta_y4);
//	Pos_dot_estim = Pos_dot_pred + (Kf23*delta_y3 + Kf24*delta_y4);
//	Pitch_estim = Pitch_pred + (Kf33*delta_y3 + Kf34*delta_y4);
//	Pitch_gyro_estim = Pitch_gyro_pred + (Kf43*delta_y3 + Kf44*delta_y4);
//	
//	// compute the matrix I - Kf*C and store it in the matrix 'tmp'
////	tmp33 = 1 - (Kf33*C33 + Kf34*C43);
////	tmp34 = 0 - (Kf33*C34 + Kf34*C44);
////	tmp43 = 0 - (Kf43*C33 + Kf44*C43);
////	tmp44 = 1 - (Kf43*C34 + Kf44*C44);
//	tmp22 = 1 - (Kf23*C32 + Kf24*C42);
//	tmp23 = 0 - (Kf23*C33 + Kf24*C43);
//	tmp24 = 0 - (Kf23*C34 + Kf24*C44);
//	tmp32 = 0 - (Kf33*C32 + Kf34*C42);
//	tmp33 = 1 - (Kf33*C33 + Kf34*C43);
//	tmp34 = 0 - (Kf33*C34 + Kf34*C44);
//	tmp42 = 0 - (Kf43*C32 + Kf44*C42);
//	tmp43 = 0 - (Kf43*C33 + Kf44*C43);
//	tmp44 = 1 - (Kf43*C34 + Kf44*C44);
//	
//	// error covariance matrix estimation: P(k) = (I - Kf*C)*P_pred(k)
////	P33 = tmp33*P_pred33 + tmp34*P_pred43;
////	P34 = tmp33*P_pred34 + tmp34*P_pred44;
////	P43 = tmp43*P_pred33 + tmp44*P_pred43;
////	P44 = tmp43*P_pred34 + tmp44*P_pred44;
//	P22 = tmp22*P_pred22 + tmp23*P_pred32 + tmp24*P_pred42;
//	P23 = tmp22*P_pred23 + tmp23*P_pred33 + tmp24*P_pred43;
//	P24 = tmp22*P_pred24 + tmp23*P_pred34 + tmp24*P_pred44;
//	P32 = tmp32*P_pred22 + tmp33*P_pred32 + tmp34*P_pred42;
//	P33 = tmp32*P_pred23 + tmp33*P_pred33 + tmp34*P_pred43;
//	P34 = tmp32*P_pred24 + tmp33*P_pred34 + tmp34*P_pred44;
//	P42 = tmp42*P_pred22 + tmp43*P_pred32 + tmp44*P_pred42;
//	P43 = tmp42*P_pred23 + tmp43*P_pred33 + tmp44*P_pred43;
//	P44 = tmp42*P_pred24 + tmp43*P_pred34 + tmp44*P_pred44;
//	
//	
//	// collect both pitch position/velocity measurements and estimations, so that we can graph and compare them
////	if (i < N) {
////		
////		Pitch_measurements[i] = y3;
////		Pitch_gyro_measurements[i] = y4;
////		Pitch_estimations[i] = Pitch_estim;
////		Pitch_gyro_estimations[i] = Pitch_gyro_estim;
////		white_noise_input[i] = u;
////		
////		if (i == N-1) {
////			//save the arrays in separated files
////			
////			char *separator = "----------";
////			u8 *separator_u8 = (u8 *) separator;
////			
////			/*
////			u8 Pitch_measurements_u8[4000];
////			unsigned int jj = 0;
////			for(unsigned int j=0; j<1000; j++) {
////				int32_t tmp = (int32_t) Pitch_measurements[j]*10000000000;	//convert the first 10 fractional digits into integer digits, and then convert the number to int
////				Pitch_measurements_u8[jj] = tmp >> 24;
////				jj++;
////				Pitch_measurements_u8[jj] = tmp >> 16;
////				jj++;
////				Pitch_measurements_u8[jj] = tmp >> 8;
////				jj++;
////				Pitch_measurements_u8[jj] = tmp;
////				jj++;
////			}
////			*/
////			
////			u8 Pitch_measurements_u8[4000];
////			
////			for(unsigned int j=0; j<1000; j++) {
////				unsigned long longdata = 0;
////				longdata = *(unsigned long*)&Pitch_measurements[j];
////				Pitch_measurements_u8[4*j] = (longdata & 0xFF000000) >> 24;
////				Pitch_measurements_u8[4*j+1] = (longdata & 0x00FF0000) >> 16;
////				Pitch_measurements_u8[4*j+2] = (longdata & 0x0000FF00) >> 8;
////				Pitch_measurements_u8[4*j+3] = (longdata & 0x000000FF);
////			}
////			
////			for (unsigned int j=0; j<20; j++) {
////				UART3_Send(Pitch_measurements_u8+j*200, 200);
////			}
////			UART3_Send(separator_u8, 10);
////			
////		}
////		
////		i++;
////	}
//}


/***************************************************************************************
*Name     	: kalman_filter_nonlinear_update
*Function 	: estimates the angular position and velocity of the robot by its inputs and outputs, using a nonlinear model of the balancing robot
*Input    	: u (input to the robot at time k-1), y3 (robot's pitch position at time k), y4 (robot's pitch velocity at time k)
*Output   	: none (the function just updates the values of Pitch_estim and Pitch_gyro_estim, which are estimations of pitch position and velocity of the robot, respectively)
*Description: it implements a state-of-the-art algorithm to solve iteratively the Riccatti equation, hence to compute Kf (the Kalman Filter gain matrix) and to estimate the robot's state
****************************************************************************************/
void kalman_filter_nonlinear_update(int16_t u, float y1, float y3)
{
	
	//NOTE: we assume that the states observed are Pos and Pitch
	
	//Taylor series of consine and sine of the previously estimated robot's angular position
//	cos_theta = 1 - (Pitch_estim*Pitch_estim)/2 + (Pitch_estim*Pitch_estim*Pitch_estim*Pitch_estim)/24 - (Pitch_estim*Pitch_estim*Pitch_estim*Pitch_estim*Pitch_estim*Pitch_estim)/720;
//	sin_theta = Pitch_estim - (Pitch_estim*Pitch_estim*Pitch_estim)/6 + (Pitch_estim*Pitch_estim*Pitch_estim*Pitch_estim*Pitch_estim)/120 - (Pitch_estim*Pitch_estim*Pitch_estim*Pitch_estim*Pitch_estim*Pitch_estim*Pitch_estim)/5040;
  cos_theta = cos(Pitch_estim);
  sin_theta = sin(Pitch_estim);
	
	/*Step 1: Prediction*/
	// state prediction: x_pred(k) = A*x_estim(k-1) + B*u(k-1)
	
	Pos_pred = Pos_estim + Tcc*Pos_dot_estim;
	Pos_dot_pred = Pos_dot_estim - Tcc*(-b*(I+m_top*l*l)*Pos_dot_estim + m_top*m_top*l*l*g*cos_theta*sin_theta - m_top*l*(I+m_top*l*l)*Pitch_gyro_estim*Pitch_gyro_estim*sin_theta + (2/r)*u) / ((I+m_top*l*l)*(M_bottom+m_top) - (m_top*l*cos_theta)*(m_top*l*cos_theta));
	Pitch_pred = Pitch_estim + Tcc*Pitch_gyro_estim;
	Pitch_gyro_pred = Pitch_gyro_estim + Tcc*((m_top*l*g*sin_theta)/(I+m_top*l*l) + ((m_top*l*cos_theta)*(-b*Pos_dot_estim - m_top*l*Pitch_gyro_estim*Pitch_gyro_estim*sin_theta))/((I+m_top*l*l)*(M_bottom+m_top)) + ((2*m_top*l*cos_theta)/((I+m_top*l*l)*(M_bottom+m_top)*r))*u) / (1 - (m_top*l*cos_theta)*(m_top*l*cos_theta)/((I+m_top*l*l)*(M_bottom+m_top)));
	Pitch_gyro_pred = Pitch_gyro_pred*0.0001;
	
	
	// compute the matrix A*P(k-1)*A^(T) and store it in the matrix 'tmp'
	tmp11 = A11*P11 + A12*P21 + A13*P31 + A14*P41;
	tmp12 = A11*P12 + A12*P22 + A13*P32 + A14*P42;
	tmp13 = A11*P13 + A12*P23 + A13*P33 + A14*P43;
	tmp14 = A11*P14 + A12*P24 + A13*P34 + A14*P44;
	tmp21 = A21*P11 + A22*P21 + A23*P31 + A24*P41;
	tmp22 = A21*P12 + A22*P22 + A23*P32 + A24*P42;
	tmp23 = A21*P13 + A22*P23 + A23*P33 + A24*P43;
	tmp24 = A21*P14 + A22*P24 + A23*P34 + A24*P44;
	tmp31 = A31*P11 + A32*P21 + A33*P31 + A34*P41;
	tmp32 = A31*P12 + A32*P22 + A33*P32 + A34*P42;
	tmp33 = A31*P13 + A32*P23 + A33*P33 + A34*P43;
	tmp34 = A31*P14 + A32*P24 + A33*P34 + A34*P44;
	tmp41 = A41*P11 + A42*P21 + A43*P31 + A44*P41;
	tmp42 = A41*P12 + A42*P22 + A43*P32 + A44*P42;
	tmp43 = A41*P13 + A42*P23 + A43*P33 + A44*P43;
	tmp44 = A41*P14 + A42*P24 + A43*P34 + A44*P44;
	// now 'tmp' stores the matrix A*P(k-1), so we can compute tmp*A^(T)
	APA11 = tmp11*A11 + tmp12*A12 + tmp13*A13 + tmp14*A14;
	APA12 = tmp11*A21 + tmp12*A22 + tmp13*A23 + tmp14*A24;
	APA13 = tmp11*A31 + tmp12*A32 + tmp13*A33 + tmp14*A34;
	APA14 = tmp11*A41 + tmp12*A42 + tmp13*A43 + tmp14*A44;
	APA21 = tmp21*A11 + tmp22*A12 + tmp23*A13 + tmp24*A14;
	APA22 = tmp21*A21 + tmp22*A22 + tmp23*A23 + tmp24*A24;
	APA23 = tmp21*A31 + tmp22*A32 + tmp23*A33 + tmp24*A34;
	APA24 = tmp21*A41 + tmp22*A42 + tmp23*A43 + tmp24*A44;
	APA31 = tmp31*A11 + tmp32*A12 + tmp33*A13 + tmp34*A14;
	APA32 = tmp31*A21 + tmp32*A22 + tmp33*A23 + tmp34*A24;
	APA33 = tmp31*A31 + tmp32*A32 + tmp33*A33 + tmp34*A34;
	APA34 = tmp31*A41 + tmp32*A42 + tmp33*A43 + tmp34*A44;
	APA41 = tmp41*A11 + tmp42*A12 + tmp43*A13 + tmp44*A14;
	APA42 = tmp41*A21 + tmp42*A22 + tmp43*A23 + tmp44*A24;
	APA43 = tmp41*A31 + tmp42*A32 + tmp43*A33 + tmp44*A34;
	APA44 = tmp41*A41 + tmp42*A42 + tmp43*A43 + tmp44*A44;

	// forecast error covariance: P_pred(k) = A*P(k-1)*A^(T) + Vd
	P_pred11 = APA11 + Vd11;
	P_pred12 = APA12 + Vd12;
	P_pred13 = APA13 + Vd13;
	P_pred14 = APA14 + Vd14;
	P_pred21 = APA21 + Vd21;
	P_pred22 = APA22 + Vd22;
	P_pred23 = APA23 + Vd23;
	P_pred24 = APA24 + Vd24;
	P_pred31 = APA31 + Vd31;
	P_pred32 = APA32 + Vd32;
	P_pred33 = APA33 + Vd33;
	P_pred34 = APA34 + Vd34;
	P_pred41 = APA41 + Vd41;
	P_pred42 = APA42 + Vd42;
	P_pred43 = APA43 + Vd43;
	P_pred44 = APA44 + Vd44;
	
	/*Step 2: Update predictions*/
	// compute the matrix C*P_pred(k)*C^(T) and store it in the matrix 'tmp'
	tmp11 = P_pred11*C11 + P_pred12*C12 + P_pred13*C13 + P_pred14*C14;
	tmp13 = P_pred11*C31 + P_pred12*C32 + P_pred13*C33 + P_pred14*C34;
	tmp21 = P_pred21*C11 + P_pred22*C12 + P_pred23*C13 + P_pred24*C14;
	tmp23 = P_pred21*C31 + P_pred22*C32 + P_pred23*C33 + P_pred24*C34;
	tmp31 = P_pred31*C11 + P_pred32*C12 + P_pred33*C13 + P_pred34*C14;
	tmp33 = P_pred31*C31 + P_pred32*C32 + P_pred33*C33 + P_pred34*C34;
	tmp41 = P_pred41*C11 + P_pred42*C12 + P_pred43*C13 + P_pred44*C14;
	tmp43 = P_pred41*C31 + P_pred42*C32 + P_pred43*C33 + P_pred44*C34;
	// now 'tmp' stores the matrix P_pred(k)*C^(T), and we can compute C*tmp
	CPC11 = C11*tmp11 + C12*tmp21 + C13*tmp31 + C14*tmp41;
	CPC13 = C11*tmp13 + C12*tmp23 + C13*tmp33 + C14*tmp43;
	CPC31 = C31*tmp11 + C32*tmp21 + C33*tmp31 + C34*tmp41;
	CPC33 = C31*tmp13 + C32*tmp23 + C33*tmp33 + C34*tmp43;
	
	// innovation covariance matrix: S(k) = C*P_pred(k)*C^(T) + Vn
	S11 = CPC11 + Vn11;
	S13 = CPC13 + Vn13;
	S31 = CPC31 + Vn31;
	S33 = CPC33 + Vn33;
	
	// compute the inverse of the 2x2 innovation matrix S(k)^(-1)
	S_det = S11*S33 - S13*S31;
	S_inv11 = S33/S_det;
	S_inv13 = -S13/S_det;
	S_inv31 = -S31/S_det;
	S_inv33 = S11/S_det;
	
	// compute Kalman Filter gain matrix: Kf(k) = P_pred(k)*C^(T)*S(k)^(-1)
	Kf11 = tmp11*S_inv11 + tmp13*S_inv31;
	Kf13 = tmp11*S_inv13 + tmp13*S_inv33;
	Kf21 = tmp21*S_inv11 + tmp23*S_inv31;
	Kf23 = tmp21*S_inv13 + tmp23*S_inv33;
	Kf31 = tmp31*S_inv11 + tmp33*S_inv31;
	Kf33 = tmp31*S_inv13 + tmp33*S_inv33;
	Kf41 = tmp41*S_inv11 + tmp43*S_inv31;
	Kf43 = tmp41*S_inv13 + tmp43*S_inv33;
	
	// error between prediction's output and actual output: delta_y(k) = y(k) - C*x_pred(k)
	delta_y1 = y1 - (C11*Pos_pred + C12*Pos_dot_pred + C13*Pitch_pred + C14*Pitch_gyro_pred);
	delta_y3 = y3 - (C31*Pos_pred + C32*Pos_dot_pred + C33*Pitch_pred + C34*Pitch_gyro_pred);
	
	// state estimation by means of 'a posteriori' correction of the state prediction: x_estim(k) = x_pred(k) + Kf*delta_y(k)
	Pos_estim = Pos_pred + (Kf11*delta_y1 + Kf13*delta_y3);
	Pos_dot_estim = Pos_dot_pred + (Kf21*delta_y1 + Kf23*delta_y3);
	Pitch_estim = Pitch_pred + (Kf31*delta_y1 + Kf33*delta_y3);
	Pitch_gyro_estim = Pitch_gyro_pred + (Kf41*delta_y1 + Kf43*delta_y3);
	
	// compute the matrix I - Kf*C and store it in the matrix 'tmp'
	tmp11 = 1 - (Kf11*C11 + Kf13*C31);
	tmp12 = 0 - (Kf11*C12 + Kf13*C32);
	tmp13 = 0 - (Kf11*C13 + Kf13*C33);
	tmp14 = 0 - (Kf11*C14 + Kf13*C34);
	tmp21 = 0 - (Kf21*C11 + Kf23*C31);
	tmp22 = 1 - (Kf21*C12 + Kf23*C32);
	tmp23 = 0 - (Kf21*C13 + Kf23*C33);
	tmp24 = 0 - (Kf21*C14 + Kf23*C34);
	tmp31 = 0 - (Kf31*C11 + Kf33*C31);
	tmp32 = 0 - (Kf31*C12 + Kf33*C32);
	tmp33 = 1 - (Kf31*C13 + Kf33*C33);
	tmp34 = 0 - (Kf31*C14 + Kf33*C34);
	tmp41 = 0 - (Kf41*C11 + Kf43*C31);
	tmp42 = 0 - (Kf41*C12 + Kf43*C32);
	tmp43 = 0 - (Kf41*C13 + Kf43*C33);
	tmp44 = 1 - (Kf41*C14 + Kf43*C34);
	
	// error covariance matrix estimation: P(k) = (I - Kf*C)*P_pred(k)
	P11 = tmp11*P_pred11 + tmp12*P_pred21 + tmp13*P_pred31 + tmp14*P_pred41;
	P12 = tmp11*P_pred12 + tmp12*P_pred22 + tmp13*P_pred32 + tmp14*P_pred42;
	P13 = tmp11*P_pred13 + tmp12*P_pred23 + tmp13*P_pred33 + tmp14*P_pred43;
	P14 = tmp11*P_pred14 + tmp12*P_pred24 + tmp13*P_pred34 + tmp14*P_pred44;
	P21 = tmp21*P_pred11 + tmp22*P_pred21 + tmp23*P_pred31 + tmp24*P_pred41;
	P22 = tmp21*P_pred12 + tmp22*P_pred22 + tmp23*P_pred32 + tmp24*P_pred42;
	P23 = tmp21*P_pred13 + tmp22*P_pred23 + tmp23*P_pred33 + tmp24*P_pred43;
	P24 = tmp21*P_pred14 + tmp22*P_pred24 + tmp23*P_pred34 + tmp24*P_pred44;
	P31 = tmp31*P_pred11 + tmp32*P_pred21 + tmp33*P_pred31 + tmp34*P_pred41;
	P32 = tmp31*P_pred12 + tmp32*P_pred22 + tmp33*P_pred32 + tmp34*P_pred42;
	P33 = tmp31*P_pred13 + tmp32*P_pred23 + tmp33*P_pred33 + tmp34*P_pred43;
	P34 = tmp31*P_pred14 + tmp32*P_pred24 + tmp33*P_pred34 + tmp34*P_pred44;
	P41 = tmp41*P_pred11 + tmp42*P_pred21 + tmp43*P_pred31 + tmp44*P_pred41;
	P42 = tmp41*P_pred12 + tmp42*P_pred22 + tmp43*P_pred32 + tmp44*P_pred42;
	P43 = tmp41*P_pred13 + tmp42*P_pred23 + tmp43*P_pred33 + tmp44*P_pred43;
	P44 = tmp41*P_pred14 + tmp42*P_pred24 + tmp43*P_pred34 + tmp44*P_pred44;
	
	kalman_filter_results[0] = Pos_estim;
	kalman_filter_results[1] = Pos_dot_estim;
	kalman_filter_results[2] = Pitch_estim;
	kalman_filter_results[3] = Pitch_gyro_estim;
}	






//void computeContiguousEncoderPos(void) {
//	
//	currentEncoderAngle = current_position_201;
//	if (prevEncoderAngle - currentEncoderAngle > completeCircleEncoderAngle/2) roundsCounter++;
//	else if (currentEncoderAngle - prevEncoderAngle > completeCircleEncoderAngle/2) roundsCounter--;
//	
//	contiguousEncoderPos = currentEncoderAngle + roundsCounter*completeCircleEncoderAngle;
//	
//	prevEncoderAngle = currentEncoderAngle;
//}




/*-------------  底盘停止  -------------*/
void CMStop(void)
{
    CAN1_Send_Bottom(0,0,0,0);
}


/***************************************************************************************
 *Name     : move
 *Function ：计算底盘电机速度给定值 由遥控器控制。同时有各个轮子的速度限制
 *Input    ：speedX, speedY, rad
 *Output   ：无
 *Description :改变了全局变量	speedA, speedB, speedC, speedD
****************************************************************************************/
void move(int16_t speedX, int16_t speedY, int16_t rad)
{
    float max_speed=0;
    speedX *= gears_speedXYZ;
    speedY *= gears_speedXYZ;
    rad *= gears_speedRAD;


//		if(fabs(speedY)>6000&&fabs(rad)<100)
//		{
//			rad*=10;
//		}

    int16_t speedA = ( speedX + speedY + rad);
    int16_t speedB = ( speedX - speedY + rad);
    int16_t speedC = (-speedX - speedY + rad);
    int16_t speedD = (-speedX + speedY + rad);

    if(fabs(speedA)>max_speed)
        max_speed=fabs(speedA);
    if(fabs(speedB)>max_speed)
        max_speed=fabs(speedB);
    if(fabs(speedC)>max_speed)
        max_speed=fabs(speedC);
    if(fabs(speedD)>max_speed)
        max_speed=fabs(speedD);

    if(max_speed>max_output_speed)
    {
        speedA*=max_output_speed/max_speed;
        speedB*=max_output_speed/max_speed;
        speedC*=max_output_speed/max_speed;
        speedD*=max_output_speed/max_speed;
    }

    CMControlOut(speedA,speedB,speedC,speedD);
}


void key_move(int16_t speedX, int16_t speedY, int16_t rad)
{
    float max_speed=0;
    rad *= gears_speedRAD;

    if(fabs(speedY)>5000&&fabs(rad)<50&&fabs(rad)>5)
    {
        rad*=10;
    }
    int16_t speedA = ( speedX + speedY + rad);
    int16_t speedB = ( speedX - speedY + rad);
    int16_t speedC = (-speedX - speedY+ rad);
    int16_t speedD = (-speedX + speedY + rad);

    if(fabs(speedA)>max_speed)
        max_speed=fabs(speedA);
    if(fabs(speedB)>max_speed)
        max_speed=fabs(speedB);
    if(fabs(speedC)>max_speed)
        max_speed=fabs(speedC);
    if(fabs(speedD)>max_speed)
        max_speed=fabs(speedD);

    if(max_speed>max_output_speed)
    {
        speedA*=max_output_speed/max_speed;
        speedB*=max_output_speed/max_speed;
        speedC*=max_output_speed/max_speed;
        speedD*=max_output_speed/max_speed;
    }

    CMControlOut(speedA,speedB,speedC,speedD);
}



/***************************************************************************************
 *Name     : CMControlOut
 *Function ：底盘电机速度输出，经过PID控制器，发送给电机驱动器，同时有各个轮子的速度限制
 *Input    ：speedA,speedB,speedC,speedD
 *Output   ：无
 *Description : 底盘电机速度环和幅值函数
****************************************************************************************/
int16_t out_a=0;
float lec_numA=3000;
float lec_numB=3000;
float lec_numC=3000;
float lec_numD=3000;

int16_t pre_current_A=0;
int16_t pre_current_B=0;
int16_t pre_current_C=0;
int16_t pre_current_D=0;
int16_t current_step=600;//80;
u8 super_cap_flag=0;
void CMControlOut(int16_t spa , int16_t spb ,int16_t spc ,int16_t spd )
{

    float current_sum=0;
    int max_now_speed=0;
	
    float speedA = PID_ControllerDriver(&SPCHIASSISA,spa,current_cm_201);
    float speedB = PID_ControllerDriver(&SPCHIASSISB,spb,current_cm_202);
    float speedC = PID_ControllerDriver(&SPCHIASSISC,spc,current_cm_203);
    float speedD = PID_ControllerDriver(&SPCHIASSISD,spd,current_cm_204);
		
		/* Recovering the input sent to wheels, so that it can be used in the Kalman Filter.
		* The input sent to the motor's speed controller is in the range [-16384, +16384], which corresponds to
		* a current range of [-20A, +20A]. The motor then produces a torque that is proportional to the
		* received current and based on its Torque Constant Km = 0.741 N*m/A */
	speedA_value = speedA;	
	speedB_value = speedB;	
	input_to_wheel_L = (speedA*20/16384)*0.741;		//measurement unit: torque [N*m]
	input_to_wheel_R = (speedB*20/16384)*0.741;		//measurement unit: torque [N*m]
	
   // if(cap_receive.state_module==Cap_Run&&cap_receive.state_cap==Cap_Boost&&cap_receive.CapVol>11800)
    if(1)
    {
        CAN1_Send_Bottom(speedA,speedB,speedC,speedD);
        super_cap_flag=0;
    }
    else
    {
        super_cap_flag=1;
        if(abs(current_cm_201)>max_now_speed)
            max_now_speed=abs(current_cm_201);
        if(abs(current_cm_202)>max_now_speed)
            max_now_speed=abs(current_cm_202);
        if(abs(current_cm_203)>max_now_speed)
            max_now_speed=abs(current_cm_203);
        if(abs(current_cm_204)>max_now_speed)
            max_now_speed=abs(current_cm_204);


        if(abs(speedA-pre_current_A)>current_step)
        {
            if(speedA-pre_current_A>current_step)
                speedA=pre_current_A+current_step;
            else if(speedA-pre_current_A<-current_step)
                speedA=pre_current_A-current_step;
        }

        if(abs(speedB-pre_current_B)>current_step)
        {
            if(speedB-pre_current_B>current_step)
                speedB=pre_current_B+current_step;
            else if(speedB-pre_current_B<-current_step)
                speedB=pre_current_B-current_step;
        }
        if(abs(speedC-pre_current_C)>current_step)
        {
            if(speedC-pre_current_C>current_step)
                speedC=pre_current_C+current_step;
            else if(speedC-pre_current_C<-current_step)
                speedC=pre_current_C-current_step;
        }
        if(abs(speedD-pre_current_D)>current_step)
        {
            if(speedD-pre_current_D>current_step)
                speedD=pre_current_D+current_step;
            else if(speedD-pre_current_D<-current_step)
                speedD=pre_current_D-current_step;
        }
        current_sum=fabs(speedA)+fabs(speedB)+fabs(speedC)+fabs(speedD);



        if(current_sum > max_output_current)
        {
            speedA*=(max_output_current)/current_sum;
            speedB*=(max_output_current)/current_sum;
            speedC*=(max_output_current)/current_sum;
            speedD*=(max_output_current)/current_sum;
        }
        CAN1_Send_Bottom(speedA,speedB,speedC,speedD);
    }

    output_current_sum=abs(speedA)+abs(speedB)+abs(speedC)+abs(speedD);
    pre_current_A=speedA;
    pre_current_B=speedB;
    pre_current_C=speedC;
    pre_current_D=speedD;


}


/**********  底盘电机幅值限制  **********/
float CMSpeedLegalize(float MotorCurrent , float limit)
{
    return MotorCurrent<-limit?-limit:(MotorCurrent>limit?limit:MotorCurrent);
}


/***************************************************************************************
 *Name     : followValCal
 *Function ：底盘电机跟随计算
 *Input    ：Setposition,Yaw轴电机码盘跟随值
 *Output   ：底盘跟随量
 *Description : 底盘电机跟随量计算函数
****************************************************************************************/
int16_t followValCal(float Setposition)
{
    int16_t followVal = 0;
    float NowPosition = position_yaw_relative;
    followVal=PID_ControllerDriver(&SPFOLLOW,Setposition,NowPosition);
//	float followVal_speed=PID_ControllerDriver(&SPFOLLOW_SPEED,followVal/20.0,yaw_speed);
//	followVal = CMSpeedLegalize(followVal_speed,1200);
    //跟随量最小值，角度过小不跟随
    //if(abs(followVal) < followVal_limit) followVal = 0;

    return followVal;
}



/*-------------  底盘电机速度PID和跟随PID初始化  -------------*/



/*底盘初始化*/
void CMControlInit(void)
{
    PID_ControllerInit(&SPFOLLOW,50,150,1100,0.01);
    SPFOLLOW.intergration_separation = 100;
		int16_t max_out = 5000; //this is the value to saturate the wheels' PID output
    PID_ControllerInit(&SPCHIASSISA,500,100,max_out,0.001);
    PID_ControllerInit(&SPCHIASSISB,500,100,max_out,0.001);
    PID_ControllerInit(&SPCHIASSISC,20,20,max_out,0.001);
    PID_ControllerInit(&SPCHIASSISD,20,20,max_out,0.001);
    PID_ControllerInit(&SPFOLLOW_SPEED,20,20,1500,0.001);
    PID_SetGains(&SPFOLLOW, 0.29,0.3,0.004);// 0.28,0.3,0.8
    PID_SetGains(&SPFOLLOW_SPEED,3,0.5,0.1);
    CM_Normal_PID();
		
		PID_ControllerInit(&ChassiPitchPID.Position,1000,500,8000,0.01);
    PID_ControllerInit(&ChassiPitchPID.Speed,50,50,8000,0.01);
		PID_SetGains(&ChassiPitchPID.Position,pp,pi,pd);
    PID_SetGains(&ChassiPitchPID.Speed,sp,si,sd);
	
}

void CM_Normal_PID(void)
{
    PID_SetGains(&SPCHIASSISA,cm_normal_p,cm_normal_i,cm_normal_d);
    PID_SetGains(&SPCHIASSISB,cm_normal_p,cm_normal_i,cm_normal_d);
    PID_SetGains(&SPCHIASSISC,cm_normal_p,cm_normal_i,cm_normal_d);
    PID_SetGains(&SPCHIASSISD,cm_normal_p,cm_normal_i,cm_normal_d);
	PID_SetGains(&SPFOLLOW, 0.29,0.3,0.004);// 0.28,0.3,0.8
}

void CM_Climb_PID(void)
{
    PID_SetGains(&SPCHIASSISA,cm_climb_p,cm_climb_i,cm_climb_d);
    PID_SetGains(&SPCHIASSISB,cm_climb_p,cm_climb_i,cm_climb_d);
    PID_SetGains(&SPCHIASSISC,cm_climb_p,cm_climb_i,cm_climb_d);
    PID_SetGains(&SPCHIASSISD,cm_climb_p,cm_climb_i,cm_climb_d);
	PID_SetGains(&SPFOLLOW, 0.23,0.3,0.002);// 0.28,0.3,0.8
}


void keyboardmove(uint16_t keyboardvalue,uint16_t xlimit,uint16_t ylimit)
{

    // W and S
    switch(keyboardvalue & (KEY_PRESSED_OFFSET_W|KEY_PRESSED_OFFSET_S))
    {
    case ( KEY_PRESSED_OFFSET_W):
        m = 0;
        if(keymove_y>0)
            keymove_y += 0.8f*step;
        else
            keymove_y += step*2;
        break;
    case ( KEY_PRESSED_OFFSET_S):
        m = 0;
        if(keymove_y<0)
            keymove_y -= 0.8f*step;
        else
            keymove_y -= step*2;
        break;
    default:
        m++;
        if(m>1)
        {
            if(keymove_y>3*step) {
                keymove_y=keymove_y-3*step;
            }
            else if(keymove_y<-3*step) {
                keymove_y=keymove_y+3*step;
            }
            else {
                keymove_y = 0;
            }
        }
        break;
    }

    //  A and D  stand for X axis
    switch(keyboardvalue & (KEY_PRESSED_OFFSET_A | KEY_PRESSED_OFFSET_D))
    {
    case ( KEY_PRESSED_OFFSET_A):
        n = 0;
        if(keymove_x<0)
            keymove_x -= 3*step;
        else
            keymove_x -= 3*step;
        break;
    case ( KEY_PRESSED_OFFSET_D):
        n = 0;
        if(keymove_x>0)    //正在向右
            keymove_x += 3*step;           //加步长
        else
            keymove_x += 3*step;
        break;

    default:
        n++;
        if(n>1)
        {
            if(keymove_x>3*step) {
                keymove_x=keymove_x-3*step;
            }
            else if(keymove_x<-3*step) {
                keymove_x=keymove_x+3*step;
            }
            else {
                keymove_x = 0;
            }
        }
        break;
    }
    keymove_x = keymove_x>xlimit?xlimit:(keymove_x<-xlimit?-xlimit:keymove_x);  //限速
    keymove_y = keymove_y>ylimit?ylimit:(keymove_y<-ylimit?-ylimit:keymove_y);

    if(keymove_x<5&&keymove_x>-5) keymove_x = 0;
    if(keymove_y<5&&keymove_y>-5) keymove_y = 0;	 //减少爬行

}

u8 cm_switch_delay=0;


int rotate_shift_count=0;
void CM_Switch_Moni(void)
{
    if(cm_switch_delay>0)
        cm_switch_delay--;


    if((RC_Ex_Ctl.key.v & KEY_PRESSED_OFFSET_X )==KEY_PRESSED_OFFSET_X&&cm_switch_delay<=0)
    {
        if(climb_mode_flag==1)
            climb_mode_flag=0;
        else
            climb_mode_flag=1;
        cm_switch_delay=50;
    }

    if(	rotate_shift_count>-1)
    {
        rotate_shift_count--;
    }

    if((RC_Ex_Ctl.key.v & KEY_PRESSED_OFFSET_SHIFT )==KEY_PRESSED_OFFSET_SHIFT)
    {
        rotate_shift_count=50;
    }
    if(rotate_shift_count==0&&(RC_Ex_Ctl.key.v & KEY_PRESSED_OFFSET_SHIFT )!=KEY_PRESSED_OFFSET_SHIFT)
    {
        rotate_speed_dir=-rotate_speed_dir;
    }


}




